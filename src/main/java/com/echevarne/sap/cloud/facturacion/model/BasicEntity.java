package com.echevarne.sap.cloud.facturacion.model;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Supplier;

import javax.persistence.Column;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import javax.persistence.Version;

import com.echevarne.sap.cloud.facturacion.reflection.ObjectReflectionUtil;
import com.echevarne.sap.cloud.facturacion.reflection.impl.ObjectReflectionUtilImpl;
import org.hibernate.annotations.*;
import org.hibernate.id.enhanced.SequenceStyleGenerator;
import org.hibernate.id.enhanced.StandardOptimizerDescriptor;

/**
 * Abstract super class for all the entities within the application.
 *
 * @author Steven Mendez
 * @version 1.0
 * @since 06/24/2019
 */
@MappedSuperclass
public abstract class BasicEntity implements Serializable, Comparable {

	private final static ObjectReflectionUtil OBJECT_REFLECTION = new ObjectReflectionUtilImpl();

	/**
	 * Id used as primary key.
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequence-generator")
	@GenericGenerator(
			name = "sequence-generator",
			strategy = "com.echevarne.sap.cloud.facturacion.persistence.SequenceOrIdSequenceGenerator",
			parameters = {
					@Parameter(name = "prefer_sequence_per_entity", value = "true"),
					@Parameter(name ="sequence_per_entity_suffix", value = "_SQ"),
					@Parameter(name = "initial_value", value = "10000"), // In order to avoid having problems with the test and project data
					@Parameter(name = "increment_size", value = "50"),
			}
	)
	protected Long id;

	/**
	 * Timestamp that marks the moment when the entity got created.
	 */
	@Column(name = "entity_creation_timestamp", nullable = false, updatable = false)
	@CreationTimestamp
	protected Timestamp entityCreationTimestamp = new Timestamp(System.currentTimeMillis());

	/**
	 * Timestamp that marks the moment of the last update made to the entity.
	 */
	@Column(name = "last_updated_timestamp", nullable = false)
	@UpdateTimestamp
	protected Timestamp lastUpdatedTimestamp = new Timestamp(System.currentTimeMillis());

	/**
	 * Current version (incremental value) of the entity, used for optimistic.
	 * locking
	 */
	@Column(name = "entity_version", nullable = false)
	@ColumnDefault("0")
	@Version
	protected Long entityVersion;

	@Column(name = "inactive", nullable = false)
	@ColumnDefault("false")
	protected boolean inactive;

	@Column(name = "user_create", nullable = true)
	@ColumnDefault("'Generic'")
	protected String userCreate = "Generic";

	@Column(name = "user_update", nullable = true)
	@ColumnDefault("'Generic'")
	protected String userUpdate;

	public Timestamp getEntityCreationTimestamp() {
		return entityCreationTimestamp;
	}

	public void setEntityCreationTimestamp(Timestamp entityCreationTimestamp) {
		this.entityCreationTimestamp = entityCreationTimestamp;
	}

	public Long getEntityVersion() {
		return entityVersion;
	}

	public void setEntityVersion(Long entityVersion) {
		this.entityVersion = entityVersion;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Timestamp getLastUpdatedTimestamp() {
		return lastUpdatedTimestamp;
	}

	public void setLastUpdatedTimestamp(Timestamp lastUpdatedTimestamp) {
		this.lastUpdatedTimestamp = lastUpdatedTimestamp;
	}

	public boolean isInactive() {
		return this.inactive;
	}

	public void setInactive(boolean inactive) {
		this.inactive = inactive;
	}

	public boolean getInactive() {
		return this.inactive;
	}

	public String getUserCreate() {
		return userCreate;
	}

	public void setUserCreate(String userCreate) {
		this.userCreate = userCreate;
	}

	public String getUserUpdate() {
		return userUpdate;
	}

	public void setUserUpdate(String userUpdate) {
		this.userUpdate = userUpdate;
	}

	/**
	 * Basic wrapper for the {@link BasicEntity#onEquals(Object)} method that must
	 * be implemented by all <tt>BasicEntity</tt> subclasses.
	 *
	 * @param o the reference object with which to compare.
	 *
	 * @return <tt>true</tt> if this object is considered to be equal to the
	 *         argument; <tt>false</tt> otherwise.
	 */
	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		BasicEntity e = (BasicEntity) o;
		Long thisId = getId();
		Long otherId = e.getId();
		if (thisId != null && otherId != null) {
			return thisId.equals(otherId);
		} else {
			return this.inactive == e.inactive && onEquals(e);
		}
	}

	/**
	 * Equality testing method for all persistent classes.
	 * <p/>
	 * This method's implementation must be designed and coded carefully. Since we
	 * are using Hibernate 3 as a persistence framework and entity identifiers are
	 * being generated by the DBMS, we cannot rely on Hibernate object identifiers
	 * (i.e., the <tt>BasicEntity.id</tt> field) for the <tt>equals()</tt> and
	 * <tt>hashCode()</tt> methods since it may not always have been set before
	 * these methods are called. Instead, the <tt>equals()</tt> and
	 * <tt>hashCode()</tt> methods must be based on a business key. The business key
	 * property value(s) must not change during the scope of a Hibernate session or
	 * while the persistent object belongs to a java.util.Collection (such as
	 * java.util.HashMap or java.util.HashSet).
	 * <p/>
	 * Additionally, the <tt>onEquals()</tt>
	 * implementation must respect the <tt>equals()</tt>
	 * contract; please refer to the corresponding documentation for
	 * {@link Object#equals(Object)}.
	 *
	 * @param o the reference object with which to compare.
	 *
	 * @return <tt>true</tt> if this object is considered to be equal to the
	 *         argument; <tt>false</tt> otherwise.
	 *
	 * @see BasicEntity#equals(Object)
	 * @see Object#equals(Object)
	 * @see Object#hashCode()
	 */
	public abstract boolean onEquals(Object o);


	/**
	 * Hashcode method for all persistent classes.
	 * <p/>
	 * The properties that a subclass may use for calculating a hashcode must be the
	 * same properties that are used to implement the
	 * {@link BasicEntity#onEquals(Object)} method.
	 **
	 * @return a hash code value for this object.
	 *
	 * @see BasicEntity#onEquals(Object)
	 * @see Object#hashCode()
	 */
	@Override
	public int hashCode() {
		return getClass().hashCode();
	}

	public BasicEntity copyWithoutId() {
		final BasicEntity newEntity;
		try {
			newEntity = this.getClass().newInstance();
		} catch (InstantiationException | IllegalAccessException e) {
			throw new RuntimeException(e);
		}

		OBJECT_REFLECTION.copyFields(this, newEntity, this.getCopyWithoutIdBlacklistFields());

		return newEntity;
	}


	private <T extends BasicEntity> Set<T> copyWithoutId(final Set<T> sources) {
		final Set<T> targets = new HashSet<>(sources.size());
		final Set<T> froozenSources = new HashSet<>(sources);
		//sources se va incrementando en ALGUNAS de las pasadas del ciclo
		for (final T source : froozenSources) {
			final T sourceNew = (T)source.copyWithoutId();
			targets.add(sourceNew);
		}
		return targets;
	}

	protected <U extends BasicEntity> void copyAndSetWithoutId(Supplier<Set<U>> getterFunc, Consumer<Set<U>> setterFunc) {
		final Set<U> sources = getterFunc.get();
		final Set<U> targets = copyWithoutId(sources);
		//al regresar de este m√©todo, el get de interlocutores tiene menos valores que antes

		setterFunc.accept(targets);
	}


	protected <U extends BasicEntity> void copyFieldAndSetWithoutId(Supplier<U> getterFunc, Consumer<U> setterFunc) {
		final U source = getterFunc.get();
		U target = null;
		if (source != null) {
			target = (U)source.copyWithoutId();
		}
		setterFunc.accept(target);
	}

	/**
	 * Returns a StringBuilder representing the toString function of the class
	 * implementation. This should be overridden by all children classes using
	 * <tt>super.toStringBuilder()</tt> as the base, adding properties to the
	 * returned StringBuilder.
	 *
	 * @return a <tt>StringBuilder</tt> representing the <tt>toString</tt> value of
	 *         this object.
	 */
	protected StringBuilder toStringBuilder() {
		StringBuilder sb = new StringBuilder();
		sb.append("class name = ").append(getClass().getName()).append(", id = ").append(id);
		return sb;
	}

	/**
	 * Returns toStringBuilder().toString(). Declared as 'final' to require
	 * subclasses to override the {@link #toStringBuilder()} method, a cleaner and
	 * better performing mechanism for toString();
	 *
	 * @return toStringBuilder().toString()
	 */
	@Override
	public String toString() {
		return toStringBuilder().insert(0, '[').append(']').toString();
	}

	@Override
	public int compareTo(Object o) {
		return this.getEntityCreationTimestamp().compareTo(((BasicEntity) o).getEntityCreationTimestamp());
	}

	protected Set<String> getCopyWithoutIdBlacklistFields() {
		final Set<String> fields = new HashSet<>();
		fields.add("id");
		fields.add("entityVersion");

		return fields;
	}
}
